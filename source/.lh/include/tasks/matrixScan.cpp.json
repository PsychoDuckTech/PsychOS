{
    "sourceFile": "include/tasks/matrixScan.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1736105914762,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1736106327169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n             \r\n             // Scan the column combination with the current row\r\n             for (int col = 0; col < totalCols; col++) {\r\n                 colPinsMultiplexer.fastSelect(col);\r\n-                ets_delay_us(3); // Small delay for electrical stability\r\n+                ets_delay_us(4); // Small delay for electrical stability\r\n \r\n                 bool isPressed = colPinsMultiplexer.readChannel() == LOW;\r\n                     \r\n                 // if (isPressed != keyStates[row][col]) {\r\n"
                },
                {
                    "date": 1736106721947,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,8 @@\n #include <Arduino.h>\r\n #include \"config.h\"\r\n #include \"drivers/multiplexer/CD74HC4067.h\"\r\n #include \"USB.h\"\r\n-#include \"TUSB.h\"\r\n \r\n #define keyMap keyMapL0\r\n #define keyName keyNameL0\r\n \r\n"
                },
                {
                    "date": 1736282753478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,15 @@\n #include <Arduino.h>\n+#include <Keyboard.h>\n #include \"config.h\"\n #include \"drivers/multiplexer/CD74HC4067.h\"\n #include \"USB.h\"\n \n #define keyMap keyMapL0\n #define keyName keyNameL0\n \n // State tracking for debounce\n-//bool keyStates[totalRows][totalCols] = {false};\n+static bool keyStates[totalRows][totalCols] = {false};\n \n void matrixScan(void *parameters) {\n     Serial.println(task_keyScanning_started); Serial.println(\"\\n\");\n \n@@ -23,16 +24,13 @@\n             for (int col = 0; col < totalCols; col++) {\n                 colPinsMultiplexer.fastSelect(col);\n                 ets_delay_us(4); // Small delay for electrical stability\n \n+                // In an active-low design, LOW means the key is pressed\n                 bool isPressed = colPinsMultiplexer.readChannel() == LOW;\n                     \n-                // if (isPressed != keyStates[row][col]) {\n-                //     keyStates[row][col] = isPressed;\n-                //     submitKeyPress(keyMap[row][col], isPressed);\n-                // }\n-\n-                if (isPressed) {\n+                if (isPressed != keyStates[row][col]) {\n+                    keyStates[row][col] = isPressed;\n                     switch (keyMap[row][col]) {\n                         case 0:\n                             Serial.printf(\"Empty key\\n\");\n                             break;\n@@ -40,9 +38,32 @@\n                             Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n                             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n                             break;\n                     }\n+\n+                    // If key state changed from 'not pressed' to 'pressed'\n+                    if (isPressed && !keyStates[row][col]) {\n+                      keyStates[row][col] = true;\n+                      Keyboard.press(keyMap[row][col]); \n+                    }\n+                    // If key state changed from 'pressed' to 'not pressed'\n+                    else if (!isPressed && keyStates[row][col]) {\n+                      keyStates[row][col] = false;\n+                      Keyboard.release(keyMap[row][col]);\n+                    }\n                 }\n+\n+                // if (isPressed) {\n+                //     switch (keyMap[row][col]) {\n+                //         case 0:\n+                //             Serial.printf(\"Empty key\\n\");\n+                //             break;\n+                //         default:\n+                //             Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                //             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                //             break;\n+                //     }\n+                // }\n                 // pollCount[row][col]++;\n             }\n             GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\n         }\n"
                },
                {
                    "date": 1736320730937,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,57 +1,66 @@\n-#include <Arduino.h>\r\n-#include <Keyboard.h>\n-#include \"config.h\"\r\n-#include \"drivers/multiplexer/CD74HC4067.h\"\r\n-#include \"USB.h\"\r\n-\r\n-#define keyMap keyMapL0\r\n-#define keyName keyNameL0\r\n-\r\n-// State tracking for debounce\r\n+#include <Arduino.h>\n+#include <Adafruit_TinyUSB.h>\n+#include \"config.h\"\n+#include \"drivers/multiplexer/CD74HC4067.h\"\n+#include \"USB.h\"\n+\n+#define keyMap keyMapL0\n+#define keyName keyNameL0\n+\n+// State tracking for debounce\n static bool keyStates[totalRows][totalCols] = {false};\n-\r\n-void matrixScan(void *parameters) {\r\n-    Serial.println(task_keyScanning_started); Serial.println(\"\\n\");\r\n-\r\n-    // unsigned long lastTime = millis();\r\n-    // unsigned long pollCount[totalRows][totalCols] = {0};\r\n-\r\n-    for (;;) {\r\n-        for (int row = 0; row < totalRows; row++) {\r\n-            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\r\n-            \r\n-            // Scan the column combination with the current row\r\n-            for (int col = 0; col < totalCols; col++) {\r\n-                colPinsMultiplexer.fastSelect(col);\r\n-                ets_delay_us(4); // Small delay for electrical stability\r\n-\r\n+\n+void matrixScan(void *parameters)\n+{\n+    Serial.println(task_keyScanning_started);\n+    Serial.println(\"\\n\");\n+\n+    // unsigned long lastTime = millis();\n+    // unsigned long pollCount[totalRows][totalCols] = {0};\n+\n+    for (;;)\n+    {\n+        for (int row = 0; row < totalRows; row++)\n+        {\n+            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\n+\n+            // Scan the column combination with the current row\n+            for (int col = 0; col < totalCols; col++)\n+            {\n+                colPinsMultiplexer.fastSelect(col);\n+                ets_delay_us(4); // Small delay for electrical stability\n+\n                 // In an active-low design, LOW means the key is pressed\n-                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\r\n-                    \r\n-                if (isPressed != keyStates[row][col]) {\n+                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\n+\n+                if (isPressed != keyStates[row][col])\n+                {\n                     keyStates[row][col] = isPressed;\n-                    switch (keyMap[row][col]) {\r\n-                        case 0:\r\n-                            Serial.printf(\"Empty key\\n\");\r\n-                            break;\r\n-                        default:\r\n-                            Serial.printf(\"Key: %s\\n\", keyName[row][col]);\r\n-                            Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\r\n-                            break;\r\n-                    }\r\n+                    switch (keyMap[row][col])\n+                    {\n+                    case 0:\n+                        Serial.printf(\"Empty key\\n\");\n+                        break;\n+                    default:\n+                        Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                        Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                        break;\n+                    }\n \n                     // If key state changed from 'not pressed' to 'pressed'\n-                    if (isPressed && !keyStates[row][col]) {\n-                      keyStates[row][col] = true;\n-                      Keyboard.press(keyMap[row][col]); \n+                    if (isPressed && !keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = true;\n+                        Keyboard.press(keyMap[row][col]);\n                     }\n                     // If key state changed from 'pressed' to 'not pressed'\n-                    else if (!isPressed && keyStates[row][col]) {\n-                      keyStates[row][col] = false;\n-                      Keyboard.release(keyMap[row][col]);\n+                    else if (!isPressed && keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = false;\n+                        Keyboard.release(keyMap[row][col]);\n                     }\n-                }\r\n+                }\n \n                 // if (isPressed) {\n                 //     switch (keyMap[row][col]) {\n                 //         case 0:\n@@ -62,26 +71,26 @@\n                 //             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n                 //             break;\n                 //     }\n                 // }\n-                // pollCount[row][col]++;\r\n-            }\r\n-            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\r\n-        }\r\n-\r\n-        // Print individual key polling rates\r\n-        //unsigned long currentTime = millis();\r\n-        //if (currentTime - lastTime >= 1000) {\r\n-        //    Serial.println(\"Individual key polling rates (polls/sec):\");\r\n-        //    for (int row = 0; row < totalRows; row++) {\r\n-        //        for (int col = 0; col < totalCols; col++) {\r\n-        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\r\n-        //            pollCount[row][col] = 0; // Reset the count for the next second\r\n-        //        }\r\n-        //    }\r\n-        //    lastTime = currentTime;\r\n-        //}\r\n-\r\n-        vTaskDelay(1);\r\n-        //delayMicroseconds(500); // 0.5ms delay\r\n-    }\r\n+                // pollCount[row][col]++;\n+            }\n+            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\n+        }\n+\n+        // Print individual key polling rates\n+        // unsigned long currentTime = millis();\n+        // if (currentTime - lastTime >= 1000) {\n+        //    Serial.println(\"Individual key polling rates (polls/sec):\");\n+        //    for (int row = 0; row < totalRows; row++) {\n+        //        for (int col = 0; col < totalCols; col++) {\n+        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\n+        //            pollCount[row][col] = 0; // Reset the count for the next second\n+        //        }\n+        //    }\n+        //    lastTime = currentTime;\n+        //}\n+\n+        vTaskDelay(1);\n+        // delayMicroseconds(500); // 0.5ms delay\n+    }\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1736321595982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,15 +50,15 @@\n                     // If key state changed from 'not pressed' to 'pressed'\n                     if (isPressed && !keyStates[row][col])\n                     {\n                         keyStates[row][col] = true;\n-                        Keyboard.press(keyMap[row][col]);\n+                        TinyUSB_Keyboard.press(keyMap[row][col]);\n                     }\n                     // If key state changed from 'pressed' to 'not pressed'\n                     else if (!isPressed && keyStates[row][col])\n                     {\n                         keyStates[row][col] = false;\n-                        Keyboard.release(keyMap[row][col]);\n+                        TinyUSB_Keyboard.release(keyMap[row][col]);\n                     }\n                 }\n \n                 // if (isPressed) {\n"
                },
                {
                    "date": 1736321874593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -6,13 +6,17 @@\n \n #define keyMap keyMapL0\n #define keyName keyNameL0\n \n+Adafruit_USBD_HID usb_hid;\n+\n // State tracking for debounce\n static bool keyStates[totalRows][totalCols] = {false};\n \n void matrixScan(void *parameters)\n {\n+    int usb_hid_poll_interval = 1; // Set HID poll interval to 1ms (1kHz)\n+\n     Serial.println(task_keyScanning_started);\n     Serial.println(\"\\n\");\n \n     // unsigned long lastTime = millis();\n"
                },
                {
                    "date": 1736322016158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,103 @@\n+#include <Arduino.h>\n+#include <Adafruit_TinyUSB.h>\n+#include \"config.h\"\n+#include \"drivers/multiplexer/CD74HC4067.h\"\n+#include \"USB.h\"\n+\n+#define keyMap keyMapL0\n+#define keyName keyNameL0\n+\n+Adafruit_USBD_HID usb_hid;\n+\n+// State tracking for debounce\n+static bool keyStates[totalRows][totalCols] = {false};\n+\n+void matrixScan(void *parameters)\n+{\n+    int usb_hid_poll_interval = 1; // Set HID poll interval to 1ms (1kHz)\n+\n+    usb_hid.begin();\n+    usb_hid.setPollInterval(usb_hid_poll_interval);\n+\n+    Serial.println(task_keyScanning_started);\n+    Serial.println(\"\\n\");\n+\n+    // unsigned long lastTime = millis();\n+    // unsigned long pollCount[totalRows][totalCols] = {0};\n+\n+    for (;;)\n+    {\n+        for (int row = 0; row < totalRows; row++)\n+        {\n+            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\n+\n+            // Scan the column combination with the current row\n+            for (int col = 0; col < totalCols; col++)\n+            {\n+                colPinsMultiplexer.fastSelect(col);\n+                ets_delay_us(4); // Small delay for electrical stability\n+\n+                // In an active-low design, LOW means the key is pressed\n+                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\n+\n+                if (isPressed != keyStates[row][col])\n+                {\n+                    keyStates[row][col] = isPressed;\n+                    switch (keyMap[row][col])\n+                    {\n+                    case 0:\n+                        Serial.printf(\"Empty key\\n\");\n+                        break;\n+                    default:\n+                        Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                        Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                        break;\n+                    }\n+\n+                    // If key state changed from 'not pressed' to 'pressed'\n+                    if (isPressed && !keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = true;\n+                        usb_hid.keyboardPress(keyMap[row][col], 0);\n+                    }\n+                    // If key state changed from 'pressed' to 'not pressed'\n+                    else if (!isPressed && keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = false;\n+                        usb_hid.keyboardRelease(keyMap[row][col]);\n+                    }\n+                }\n+\n+                // if (isPressed) {\n+                //     switch (keyMap[row][col]) {\n+                //         case 0:\n+                //             Serial.printf(\"Empty key\\n\");\n+                //             break;\n+                //         default:\n+                //             Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                //             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                //             break;\n+                //     }\n+                // }\n+                // pollCount[row][col]++;\n+            }\n+            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\n+        }\n+\n+        // Print individual key polling rates\n+        // unsigned long currentTime = millis();\n+        // if (currentTime - lastTime >= 1000) {\n+        //    Serial.println(\"Individual key polling rates (polls/sec):\");\n+        //    for (int row = 0; row < totalRows; row++) {\n+        //        for (int col = 0; col < totalCols; col++) {\n+        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\n+        //            pollCount[row][col] = 0; // Reset the count for the next second\n+        //        }\n+        //    }\n+        //    lastTime = currentTime;\n+        //}\n+\n+        vTaskDelay(1);\n+        // delayMicroseconds(500); // 0.5ms delay\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1736322545195,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,108 @@\n+#include <Arduino.h>\n+#include <Adafruit_TinyUSB.h>\n+#include \"config.h\"\n+#include \"drivers/multiplexer/CD74HC4067.h\"\n+#include \"USB.h\"\n+\n+#define keyMap keyMapL0\n+#define keyName keyNameL0\n+\n+Adafruit_USBD_HID usb_hid;\n+\n+// State tracking for debounce\n+static bool keyStates[totalRows][totalCols] = {false};\n+\n+void matrixScan(void *parameters)\n+{\n+    int usb_hid_poll_interval = 1; // Set HID poll interval to 1ms (1kHz)\n+\n+    usb_hid.begin();\n+    usb_hid.setPollInterval(usb_hid_poll_interval);\n+\n+    while (!TinyUSBDevice.mounted())\n+    {\n+        delay(1);\n+    }\n+\n+    Serial.println(task_keyScanning_started);\n+    Serial.println(\"\\n\");\n+\n+    // unsigned long lastTime = millis();\n+    // unsigned long pollCount[totalRows][totalCols] = {0};\n+\n+    for (;;)\n+    {\n+        for (int row = 0; row < totalRows; row++)\n+        {\n+            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\n+\n+            // Scan the column combination with the current row\n+            for (int col = 0; col < totalCols; col++)\n+            {\n+                colPinsMultiplexer.fastSelect(col);\n+                ets_delay_us(4); // Small delay for electrical stability\n+\n+                // In an active-low design, LOW means the key is pressed\n+                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\n+\n+                if (isPressed != keyStates[row][col])\n+                {\n+                    keyStates[row][col] = isPressed;\n+                    switch (keyMap[row][col])\n+                    {\n+                    case 0:\n+                        Serial.printf(\"Empty key\\n\");\n+                        break;\n+                    default:\n+                        Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                        Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                        break;\n+                    }\n+\n+                    // If key state changed from 'not pressed' to 'pressed'\n+                    if (isPressed && !keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = true;\n+                        usb_hid.keyboardPress(keyMap[row][col], 0);\n+                    }\n+                    // If key state changed from 'pressed' to 'not pressed'\n+                    else if (!isPressed && keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = false;\n+                        usb_hid.keyboardRelease(keyMap[row][col]);\n+                    }\n+                }\n+\n+                // if (isPressed) {\n+                //     switch (keyMap[row][col]) {\n+                //         case 0:\n+                //             Serial.printf(\"Empty key\\n\");\n+                //             break;\n+                //         default:\n+                //             Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                //             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                //             break;\n+                //     }\n+                // }\n+                // pollCount[row][col]++;\n+            }\n+            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\n+        }\n+\n+        // Print individual key polling rates\n+        // unsigned long currentTime = millis();\n+        // if (currentTime - lastTime >= 1000) {\n+        //    Serial.println(\"Individual key polling rates (polls/sec):\");\n+        //    for (int row = 0; row < totalRows; row++) {\n+        //        for (int col = 0; col < totalCols; col++) {\n+        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\n+        //            pollCount[row][col] = 0; // Reset the count for the next second\n+        //        }\n+        //    }\n+        //    lastTime = currentTime;\n+        //}\n+\n+        vTaskDelay(1);\n+        // delayMicroseconds(500); // 0.5ms delay\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1736322576671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,110 @@\n+#include <Arduino.h>\n+#include <Adafruit_TinyUSB.h>\n+#include \"config.h\"\n+#include \"drivers/multiplexer/CD74HC4067.h\"\n+#include \"USB.h\"\n+\n+#define keyMap keyMapL0\n+#define keyName keyNameL0\n+\n+Adafruit_USBD_HID usb_hid;\n+\n+// State tracking for debounce\n+static bool keyStates[totalRows][totalCols] = {false};\n+\n+void matrixScan(void *parameters)\n+{\n+    int usb_hid_poll_interval = 1; // Set HID poll interval to 1ms (1kHz)\n+\n+    usb_hid.begin();\n+    usb_hid.setPollInterval(usb_hid_poll_interval);\n+\n+    while (!TinyUSBDevice.mounted())\n+    {\n+        delay(1);\n+    }\n+\n+    TinyUSB_Device_Task();\n+\n+    Serial.println(task_keyScanning_started);\n+    Serial.println(\"\\n\");\n+\n+    // unsigned long lastTime = millis();\n+    // unsigned long pollCount[totalRows][totalCols] = {0};\n+\n+    for (;;)\n+    {\n+        for (int row = 0; row < totalRows; row++)\n+        {\n+            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\n+\n+            // Scan the column combination with the current row\n+            for (int col = 0; col < totalCols; col++)\n+            {\n+                colPinsMultiplexer.fastSelect(col);\n+                ets_delay_us(4); // Small delay for electrical stability\n+\n+                // In an active-low design, LOW means the key is pressed\n+                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\n+\n+                if (isPressed != keyStates[row][col])\n+                {\n+                    keyStates[row][col] = isPressed;\n+                    switch (keyMap[row][col])\n+                    {\n+                    case 0:\n+                        Serial.printf(\"Empty key\\n\");\n+                        break;\n+                    default:\n+                        Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                        Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                        break;\n+                    }\n+\n+                    // If key state changed from 'not pressed' to 'pressed'\n+                    if (isPressed && !keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = true;\n+                        usb_hid.keyboardPress(keyMap[row][col], 0);\n+                    }\n+                    // If key state changed from 'pressed' to 'not pressed'\n+                    else if (!isPressed && keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = false;\n+                        usb_hid.keyboardRelease(keyMap[row][col]);\n+                    }\n+                }\n+\n+                // if (isPressed) {\n+                //     switch (keyMap[row][col]) {\n+                //         case 0:\n+                //             Serial.printf(\"Empty key\\n\");\n+                //             break;\n+                //         default:\n+                //             Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                //             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                //             break;\n+                //     }\n+                // }\n+                // pollCount[row][col]++;\n+            }\n+            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\n+        }\n+\n+        // Print individual key polling rates\n+        // unsigned long currentTime = millis();\n+        // if (currentTime - lastTime >= 1000) {\n+        //    Serial.println(\"Individual key polling rates (polls/sec):\");\n+        //    for (int row = 0; row < totalRows; row++) {\n+        //        for (int col = 0; col < totalCols; col++) {\n+        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\n+        //            pollCount[row][col] = 0; // Reset the count for the next second\n+        //        }\n+        //    }\n+        //    lastTime = currentTime;\n+        //}\n+\n+        vTaskDelay(1);\n+        // delayMicroseconds(500); // 0.5ms delay\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1736324783152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,109 @@\n+#include <Arduino.h>\n+#include \"config.h\"\n+#include \"drivers/multiplexer/CD74HC4067.h\"\n+#include \"USB.h\"\n+\n+#define keyMap keyMapL0\n+#define keyName keyNameL0\n+\n+Adafruit_USBD_HID usb_hid;\n+\n+// State tracking for debounce\n+static bool keyStates[totalRows][totalCols] = {false};\n+\n+void matrixScan(void *parameters)\n+{\n+    int usb_hid_poll_interval = 1; // Set HID poll interval to 1ms (1kHz)\n+\n+    usb_hid.begin();\n+    usb_hid.setPollInterval(usb_hid_poll_interval);\n+\n+    while (!TinyUSBDevice.mounted())\n+    {\n+        delay(1);\n+    }\n+\n+    TinyUSB_Device_Task();\n+\n+    Serial.println(task_keyScanning_started);\n+    Serial.println(\"\\n\");\n+\n+    // unsigned long lastTime = millis();\n+    // unsigned long pollCount[totalRows][totalCols] = {0};\n+\n+    for (;;)\n+    {\n+        for (int row = 0; row < totalRows; row++)\n+        {\n+            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\n+\n+            // Scan the column combination with the current row\n+            for (int col = 0; col < totalCols; col++)\n+            {\n+                colPinsMultiplexer.fastSelect(col);\n+                ets_delay_us(4); // Small delay for electrical stability\n+\n+                // In an active-low design, LOW means the key is pressed\n+                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\n+\n+                if (isPressed != keyStates[row][col])\n+                {\n+                    keyStates[row][col] = isPressed;\n+                    switch (keyMap[row][col])\n+                    {\n+                    case 0:\n+                        Serial.printf(\"Empty key\\n\");\n+                        break;\n+                    default:\n+                        Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                        Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                        break;\n+                    }\n+\n+                    // If key state changed from 'not pressed' to 'pressed'\n+                    if (isPressed && !keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = true;\n+                        usb_hid.keyboardPress(keyMap[row][col], 0);\n+                    }\n+                    // If key state changed from 'pressed' to 'not pressed'\n+                    else if (!isPressed && keyStates[row][col])\n+                    {\n+                        keyStates[row][col] = false;\n+                        usb_hid.keyboardRelease(keyMap[row][col]);\n+                    }\n+                }\n+\n+                // if (isPressed) {\n+                //     switch (keyMap[row][col]) {\n+                //         case 0:\n+                //             Serial.printf(\"Empty key\\n\");\n+                //             break;\n+                //         default:\n+                //             Serial.printf(\"Key: %s\\n\", keyName[row][col]);\n+                //             Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\n+                //             break;\n+                //     }\n+                // }\n+                // pollCount[row][col]++;\n+            }\n+            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\n+        }\n+\n+        // Print individual key polling rates\n+        // unsigned long currentTime = millis();\n+        // if (currentTime - lastTime >= 1000) {\n+        //    Serial.println(\"Individual key polling rates (polls/sec):\");\n+        //    for (int row = 0; row < totalRows; row++) {\n+        //        for (int col = 0; col < totalCols; col++) {\n+        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\n+        //            pollCount[row][col] = 0; // Reset the count for the next second\n+        //        }\n+        //    }\n+        //    lastTime = currentTime;\n+        //}\n+\n+        vTaskDelay(1);\n+        // delayMicroseconds(500); // 0.5ms delay\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1736324924702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n #include <Arduino.h>\n+#include <Adafruit_TinyUSB.h>\n #include \"config.h\"\n #include \"drivers/multiplexer/CD74HC4067.h\"\n #include \"USB.h\"\n \n"
                }
            ],
            "date": 1736105914762,
            "name": "Commit-0",
            "content": "#include <Arduino.h>\r\n#include \"config.h\"\r\n#include \"drivers/multiplexer/CD74HC4067.h\"\r\n#include \"USB.h\"\r\n#include \"TUSB.h\"\r\n\r\n#define keyMap keyMapL0\r\n#define keyName keyNameL0\r\n\r\n// State tracking for debounce\r\n//bool keyStates[totalRows][totalCols] = {false};\r\n\r\nvoid matrixScan(void *parameters) {\r\n    Serial.println(task_keyScanning_started); Serial.println(\"\\n\");\r\n\r\n    // unsigned long lastTime = millis();\r\n    // unsigned long pollCount[totalRows][totalCols] = {0};\r\n\r\n    for (;;) {\r\n        for (int row = 0; row < totalRows; row++) {\r\n            GPIO.out_w1tc = (1ULL << rowPins[row]); // Activate current row pin\r\n            \r\n            // Scan the column combination with the current row\r\n            for (int col = 0; col < totalCols; col++) {\r\n                colPinsMultiplexer.fastSelect(col);\r\n                ets_delay_us(3); // Small delay for electrical stability\r\n\r\n                bool isPressed = colPinsMultiplexer.readChannel() == LOW;\r\n                    \r\n                // if (isPressed != keyStates[row][col]) {\r\n                //     keyStates[row][col] = isPressed;\r\n                //     submitKeyPress(keyMap[row][col], isPressed);\r\n                // }\r\n\r\n                if (isPressed) {\r\n                    switch (keyMap[row][col]) {\r\n                        case 0:\r\n                            Serial.printf(\"Empty key\\n\");\r\n                            break;\r\n                        default:\r\n                            Serial.printf(\"Key: %s\\n\", keyName[row][col]);\r\n                            Serial.printf(\"R: %d, C: %d\\n\\n\", row, col);\r\n                            break;\r\n                    }\r\n                }\r\n                // pollCount[row][col]++;\r\n            }\r\n            GPIO.out_w1ts = (1ULL << rowPins[row]); // Reset the row pin\r\n        }\r\n\r\n        // Print individual key polling rates\r\n        //unsigned long currentTime = millis();\r\n        //if (currentTime - lastTime >= 1000) {\r\n        //    Serial.println(\"Individual key polling rates (polls/sec):\");\r\n        //    for (int row = 0; row < totalRows; row++) {\r\n        //        for (int col = 0; col < totalCols; col++) {\r\n        //            Serial.printf(\"Key [%d][%d]: %lu\\n\", row, col, pollCount[row][col]);\r\n        //            pollCount[row][col] = 0; // Reset the count for the next second\r\n        //        }\r\n        //    }\r\n        //    lastTime = currentTime;\r\n        //}\r\n\r\n        vTaskDelay(1);\r\n        //delayMicroseconds(500); // 0.5ms delay\r\n    }\r\n}"
        }
    ]
}