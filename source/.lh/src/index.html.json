{
    "sourceFile": "src/index.html",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1737745809376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1737745809376,
            "name": "Commit-0",
            "content": "<button id=\"connect\">Connect to Keyboard</button>\n<button id=\"save\" disabled>Save Configuration</button>\n\n<script>\nclass ESP32Driver {\n    constructor(baudRate = 115200) {\n        this.port = null;\n        this.writer = null;\n        this.reader = null;\n        this.baudRate = baudRate;\n        this.capsLockStatus = false;\n        this.lastTimeUpdate = null;\n        this.connected = false;\n        this.retryTimeout = null;\n\n        // Event handlers\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.updateTimeFromSystem = this.updateTimeFromSystem.bind(this);\n        this.checkAndUpdateTime = this.checkAndUpdateTime.bind(this);\n    }\n\n    async connect() {\n        try {\n            this.port = await navigator.serial.requestPort();\n            await this.port.open({ baudRate: this.baudRate });\n            this.writer = this.port.writable.getWriter();\n            this.connected = true;\n            console.log(\"Serial connection established\");\n\n            // Start reading responses\n            this.startReading();\n\n            // Initialize device state\n            this.updateConnectionStatus(true);\n            this.updateTimeFromSystem();\n            this.updateCapsLockStatus();\n\n            // Set up event listeners and timers\n            document.addEventListener('keydown', this.handleKeyDown);\n            this.timeUpdateInterval = setInterval(this.checkAndUpdateTime, 60000);\n            this.capsLockInterval = setInterval(() => this.updateCapsLockStatus(), 1000);\n\n        } catch (error) {\n            console.error(\"Connection error:\", error);\n            this.scheduleReconnect();\n        }\n    }\n\n    async sendCommand(command) {\n        if (!this.connected) return;\n        \n        try {\n            const encoder = new TextEncoder();\n            await this.writer.write(encoder.encode(command + \"\\n\"));\n        } catch (error) {\n            console.error(\"Send command error:\", error);\n            this.scheduleReconnect();\n        }\n    }\n\n    startReading() {\n        this.reader = this.port.readable.getReader();\n        const decoder = new TextDecoder();\n        let buffer = '';\n\n        const readChunk = ({ value, done }) => {\n            if (done) {\n                console.log(\"Reader disconnected\");\n                return;\n            }\n\n            buffer += decoder.decode(value);\n            const lines = buffer.split('\\n');\n            buffer = lines.pop() || '';\n            \n            lines.forEach(line => {\n                console.log(\"Received:\", line.trim());\n                // Add response handling logic here if needed\n            });\n\n            this.reader.read().then(readChunk);\n        };\n\n        this.reader.read().then(readChunk);\n    }\n\n    updateVariable(variable, value) {\n        this.sendCommand(`${variable} ${value}`);\n    }\n\n    updateConnectionStatus(status) {\n        this.updateVariable(\"connectionStatus\", status ? 1 : 0);\n    }\n\n    updateCapsLockStatus() {\n        const newStatus = this.getCapsLockStatus();\n        if (newStatus !== this.capsLockStatus) {\n            this.capsLockStatus = newStatus;\n            this.updateVariable(\"caps\", this.capsLockStatus ? 1 : 0);\n        }\n    }\n\n    getCapsLockStatus() {\n        const fakeEvent = new KeyboardEvent('keydown', {});\n        return fakeEvent.getModifierState('CapsLock');\n    }\n\n    handleKeyDown(event) {\n        if (event.key === 'CapsLock') {\n            this.updateCapsLockStatus();\n        }\n    }\n\n    updateTimeFromSystem() {\n        const now = new Date();\n        this.updateVariable(\"time.hours\", now.getHours());\n        this.updateVariable(\"time.minutes\", now.getMinutes());\n        this.updateVariable(\"time.seconds\", now.getSeconds());\n        this.lastTimeUpdate = now;\n    }\n\n    checkAndUpdateTime() {\n        if (!this.lastTimeUpdate || new Date().getHours() !== this.lastTimeUpdate.getHours()) {\n            this.updateTimeFromSystem();\n        }\n    }\n\n    scheduleReconnect() {\n        if (this.retryTimeout) return;\n        \n        this.connected = false;\n        if (this.writer) {\n            this.writer.release();\n            this.writer = null;\n        }\n        if (this.port) this.port.close();\n        \n        console.log(\"Attempting reconnect in 1 second...\");\n        this.retryTimeout = setTimeout(async () => {\n            await this.connect();\n            this.retryTimeout = null;\n        }, 1000);\n    }\n\n    async disconnect() {\n        clearInterval(this.timeUpdateInterval);\n        clearInterval(this.capsLockInterval);\n        document.removeEventListener('keydown', this.handleKeyDown);\n        \n        if (this.writer) {\n            await this.writer.release();\n            this.writer = null;\n        }\n        if (this.port) await this.port.close();\n        this.connected = false;\n    }\n}\n\n// Usage\nlet driver = new ESP32Driver();\n\ndocument.getElementById('connect').addEventListener('click', async () => {\n    await driver.connect();\n    document.getElementById('save').disabled = false;\n});\n\ndocument.getElementById('save').addEventListener('click', async () => {\n    await driver.sendCommand(\"SET layer0.0.0=KEY_A\");\n});\n\nwindow.addEventListener('beforeunload', () => driver.disconnect());\n</script>"
        }
    ]
}