{
    "sourceFile": "src/driver.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 29,
            "patches": [
                {
                    "date": 1736973983020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1736974156076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,22 @@\n+import serial\n+\n+# Replace 'COM_PORT' with your actual serial port\n+ser = serial.Serial('COM_PORT', 115200)\n+\n+def send_data(caps_lock_status, hour, minute):\n+    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n+    ser.write(data.encode())\n+    print(f\"Sent: {data.strip()}\")\n+\n+# Example usage:\n+# caps_lock_status = True or False\n+# hour = 0 to 23\n+# minute = 0 to 59\n+caps_lock_status = True  # Replace with your logic\n+hour = 12  # Replace with your logic\n+minute = 34  # Replace with your logic\n+\n+send_data(caps_lock_status, hour, minute)\n+\n+# Close the serial connection\n+ser.close()\n"
                },
                {
                    "date": 1736974237575,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import serial\n \n-# Replace 'COM_PORT' with your actual serial port\n+# Replace 'COM_PORT' with your actual USB port\n ser = serial.Serial('COM_PORT', 115200)\n \n def send_data(caps_lock_status, hour, minute):\n     data = f\"{caps_lock_status},{hour},{minute}\\n\"\n@@ -19,38 +19,4 @@\n send_data(caps_lock_status, hour, minute)\n \n # Close the serial connection\n ser.close()\n-import usb_hid\n-from adafruit_hid.keyboard import Keyboard\n-from adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\n-import board\n-import busio\n-import time\n-\n-# Initialize USB HID components\n-i2c = busio.I2C(board.SCL, board.SDA)\n-kbd = Keyboard(usb_hid.devices)\n-layout = KeyboardLayoutUS(kbd)\n-\n-def get_caps_lock_status():\n-    # Keyboard LED states\n-    return kbd.get_leds()\n-\n-def get_current_time():\n-    return time.strftime(\"%Y-%m-%d %H:%M:%S\")\n-\n-while True:\n-    caps_lock_status = get_caps_lock_status()\n-    is_caps_lock_on = bool(caps_lock_status & 0b001)  # Mask with 0b001 to check Caps Lock state\n-    \n-    # Get current time\n-    current_time = get_current_time()\n-    print(f\"Caps Lock: {is_caps_lock_on}, Time: {current_time}\")\n-\n-    # Send Caps Lock status and current time\n-    if is_caps_lock_on:\n-        kbd.press(KEY_CAPS_LOCK)\n-    else:\n-        kbd.release(KEY_CAPS_LOCK)\n-\n-    time.sleep(1)\n"
                },
                {
                    "date": 1736974529933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n import serial\n \n # Replace 'COM_PORT' with your actual USB port\n-ser = serial.Serial('COM_PORT', 115200)\n+ser = serial.Serial('ttyACM0', 115200)\n \n def send_data(caps_lock_status, hour, minute):\n     data = f\"{caps_lock_status},{hour},{minute}\\n\"\n     ser.write(data.encode())\n"
                },
                {
                    "date": 1736974589367,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,30 @@\n+import serial\n+\n+# Find available USB ports\n+# List available ports\n+# Replace 'ttyUSB0' with the actual port if necessary\n+ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n+\n+if ports:\n+    ser = serial.Serial(ports[0], 115200)\n+    print(f\"Connected to {ports[0]}\")\n+else:\n+    print(\"No USB device found\")\n+\n+def send_data(caps_lock_status, hour, minute):\n+    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n+    ser.write(data.encode())\n+    print(f\"Sent: {data.strip()}\")\n+\n+# Example usage:\n+# caps_lock_status = True or False\n+# hour = 0 to 23\n+# minute = 0 to 59\n+caps_lock_status = True  # Replace with your logic\n+hour = 12  # Replace with your logic\n+minute = 34  # Replace with your logic\n+\n+send_data(caps_lock_status, hour, minute)\n+\n+# Close the serial connection\n+ser.close()\n"
                },
                {
                    "date": 1736974600601,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,31 @@\n+import serial\n+import os\n+\n+# Find available USB ports\n+# List available ports\n+# Replace 'ttyUSB0' with the actual port if necessary\n+ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n+\n+if ports:\n+    ser = serial.Serial(ports[0], 115200)\n+    print(f\"Connected to {ports[0]}\")\n+else:\n+    print(\"No USB device found\")\n+\n+def send_data(caps_lock_status, hour, minute):\n+    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n+    ser.write(data.encode())\n+    print(f\"Sent: {data.strip()}\")\n+\n+# Example usage:\n+# caps_lock_status = True or False\n+# hour = 0 to 23\n+# minute = 0 to 59\n+caps_lock_status = True  # Replace with your logic\n+hour = 12  # Replace with your logic\n+minute = 34  # Replace with your logic\n+\n+send_data(caps_lock_status, hour, minute)\n+\n+# Close the serial connection\n+ser.close()\n"
                },
                {
                    "date": 1736979906903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,83 +1,55 @@\n import serial\n import os\n+import time\n \n # Find available USB ports\n # List available ports\n # Replace 'ttyUSB0' with the actual port if necessary\n ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n-\n if ports:\n     ser = serial.Serial(ports[0], 115200)\n     print(f\"Connected to {ports[0]}\")\n else:\n     print(\"No USB device found\")\n+    exit()\n \n def send_data(caps_lock_status, hour, minute):\n     data = f\"{caps_lock_status},{hour},{minute}\\n\"\n     ser.write(data.encode())\n     print(f\"Sent: {data.strip()}\")\n \n-# Example usage:\n-# caps_lock_status = True or False\n-# hour = 0 to 23\n-# minute = 0 to 59\n-caps_lock_status = True  # Replace with your logic\n-hour = 12  # Replace with your logic\n-minute = 34  # Replace with your logic\n+# Initial values\n+caps_lock_status = False\n+hour = 12\n+minute = 34\n \n-send_data(caps_lock_status, hour, minute)\n-\n-# Close the serial connection\n-ser.close()\n-import serial\n-\n-# Find available USB ports\n-# List available ports\n-# Replace 'ttyUSB0' with the actual port if necessary\n-ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n-\n-if ports:\n-    ser = serial.Serial(ports[0], 115200)\n-    print(f\"Connected to {ports[0]}\")\n-else:\n-    print(\"No USB device found\")\n-\n-def send_data(caps_lock_status, hour, minute):\n-    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n-    ser.write(data.encode())\n-    print(f\"Sent: {data.strip()}\")\n-\n-# Example usage:\n-# caps_lock_status = True or False\n-# hour = 0 to 23\n-# minute = 0 to 59\n-caps_lock_status = True  # Replace with your logic\n-hour = 12  # Replace with your logic\n-minute = 34  # Replace with your logic\n-\n-send_data(caps_lock_status, hour, minute)\n-\n-# Close the serial connection\n-ser.close()\n-import serial\n-\n-# Replace 'COM_PORT' with your actual USB port\n-ser = serial.Serial('ttyACM0', 115200)\n-\n-def send_data(caps_lock_status, hour, minute):\n-    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n-    ser.write(data.encode())\n-    print(f\"Sent: {data.strip()}\")\n-\n-# Example usage:\n-# caps_lock_status = True or False\n-# hour = 0 to 23\n-# minute = 0 to 59\n-caps_lock_status = True  # Replace with your logic\n-hour = 12  # Replace with your logic\n-minute = 34  # Replace with your logic\n-\n-send_data(caps_lock_status, hour, minute)\n-\n-# Close the serial connection\n-ser.close()\n+try:\n+    toggle_interval = 5  # Toggle caps_lock_status every 5 seconds\n+    last_toggle_time = time.time()\n+    \n+    while True:\n+        start_time = time.time()\n+        \n+        # Update caps_lock_status every toggle_interval seconds\n+        if time.time() - last_toggle_time >= toggle_interval:\n+            caps_lock_status = not caps_lock_status\n+            last_toggle_time = time.time()\n+        \n+        # Update hour and minute every minute\n+        current_time = time.localtime()\n+        hour = current_time.tm_hour\n+        minute = current_time.tm_min\n+        \n+        send_data(caps_lock_status, hour, minute)\n+        \n+        # Calculate the time taken to send the data\n+        elapsed_time = time.time() - start_time\n+        \n+        # Sleep for the remaining time to maintain 100 Hz (10 ms interval)\n+        sleep_time = max(0, 0.01 - elapsed_time)\n+        time.sleep(sleep_time)\n+except KeyboardInterrupt:\n+    print(\"Exiting...\")\n+finally:\n+    # Close the serial connection\n+    ser.close()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737138800477,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import serial\n import os\n import time\n+import subprocess\n \n # Find available USB ports\n # List available ports\n # Replace 'ttyUSB0' with the actual port if necessary\n"
                },
                {
                    "date": 1737138845733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,8 +17,19 @@\n def send_data(caps_lock_status, hour, minute):\n     data = f\"{caps_lock_status},{hour},{minute}\\n\"\n     ser.write(data.encode())\n     print(f\"Sent: {data.strip()}\")\n+    \n+def get_caps_lock_status():\n+    try:\n+        output = subprocess.check_output(['xset', 'q'])\n+        output = output.decode('utf-8')\n+        for line in output.splitlines():\n+            if 'Caps Lock:' in line:\n+                return 'on' in line.split()[3]\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return False\n \n # Initial values\n caps_lock_status = False\n hour = 12\n@@ -29,8 +40,9 @@\n     last_toggle_time = time.time()\n     \n     while True:\n         start_time = time.time()\n+        caps_lock_status = get_caps_lock_status()\n         \n         # Update caps_lock_status every toggle_interval seconds\n         if time.time() - last_toggle_time >= toggle_interval:\n             caps_lock_status = not caps_lock_status\n"
                },
                {
                    "date": 1737139205141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,12 +27,12 @@\n             if 'Caps Lock:' in line:\n                 return 'on' in line.split()[3]\n     except Exception as e:\n         print(f\"Error: {e}\")\n-        return False\n+        return 0\n \n # Initial values\n-caps_lock_status = False\n+caps_lock_status = 1\n hour = 12\n minute = 34\n \n try:\n"
                },
                {
                    "date": 1737139340924,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,9 +30,9 @@\n         print(f\"Error: {e}\")\n         return 0\n \n # Initial values\n-caps_lock_status = 1\n+caps_lock_status = \"false\"\n hour = 12\n minute = 34\n \n try:\n"
                },
                {
                    "date": 1737139671384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,68 +1,79 @@\n-import serial\n-import os\n-import time\n-import subprocess\n+#include <Adafruit_ILI9341.h>\n+#include \"UI/main.h\" // main screen UI elements\n \n-# Find available USB ports\n-# List available ports\n-# Replace 'ttyUSB0' with the actual port if necessary\n-ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n-if ports:\n-    ser = serial.Serial(ports[0], 115200)\n-    print(f\"Connected to {ports[0]}\")\n-else:\n-    print(\"No USB device found\")\n-    exit()\n+#define LCD_CS 13\n+#define LCD_RST 17\n+#define LCD_RS 16\n+#define SPI_MOSI 12 // Connect to display's SDI (MOSI)\n+#define SPI_SCK 18  // Connect to display's SCK (clock)\n \n-def send_data(caps_lock_status, hour, minute):\n-    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n-    ser.write(data.encode())\n-    print(f\"Sent: {data.strip()}\")\n-    \n-def get_caps_lock_status():\n-    try:\n-        output = subprocess.check_output(['xset', 'q'])\n-        output = output.decode('utf-8')\n-        for line in output.splitlines():\n-            if 'Caps Lock:' in line:\n-                return 'on' in line.split()[3]\n-    except Exception as e:\n-        print(f\"Error: {e}\")\n-        return 0\n+Adafruit_ILI9341 tft = Adafruit_ILI9341(LCD_CS, LCD_RS, LCD_RST);\n \n-# Initial values\n-caps_lock_status = \"false\"\n-hour = 12\n-minute = 34\n+void displayHandler(void *parameters)\n+{\n+    SPI.begin(SPI_SCK, -1, SPI_MOSI); // -1 means that the MISO pin is not used\n+    tft.begin();\n+    tft.invertDisplay(true); // Ensure normal color mode\n+    tft.setRotation(2);\n+    Serial.println(\"Display Handler started.\");\n \n-try:\n-    toggle_interval = 5  # Toggle caps_lock_status every 5 seconds\n-    last_toggle_time = time.time()\n-    \n-    while True:\n-        start_time = time.time()\n-        caps_lock_status = get_caps_lock_status()\n-        \n-        # Update caps_lock_status every toggle_interval seconds\n-        if time.time() - last_toggle_time >= toggle_interval:\n-            caps_lock_status = not caps_lock_status\n-            last_toggle_time = time.time()\n-        \n-        # Update hour and minute every minute\n-        current_time = time.localtime()\n-        hour = current_time.tm_hour\n\\ No newline at end of file\n-        minute = current_time.tm_min\n-        \n-        send_data(caps_lock_status, hour, minute)\n-        \n-        # Calculate the time taken to send the data\n-        elapsed_time = time.time() - start_time\n-        \n-        # Sleep for the remaining time to maintain 100 Hz (10 ms interval)\n-        sleep_time = max(0, 0.01 - elapsed_time)\n-        time.sleep(sleep_time)\n-except KeyboardInterrupt:\n-    print(\"Exiting...\")\n-finally:\n-    # Close the serial connection\n-    ser.close()\n+    bool capsLockStatus = false;\n+    int hour = 0;\n+    int minute = 0;\n+    bool newDataReceived = false;\n+\n+    for (;;)\n+    {\n+        if (Serial.available())\n+        {\n+            String line = Serial.readStringUntil('\\n');\n+            Serial.println(line);\n+\n+            // Parse the received data\n+            int comma1 = line.indexOf(',');\n+            int comma2 = line.lastIndexOf(',');\n+            capsLockStatus = line.substring(0, comma1).toInt() == 1;\n+            hour = line.substring(comma1 + 1, comma2).toInt();\n+            minute = line.substring(comma2 + 1).toInt();\n+            newDataReceived = true;\n+        }\n+\n+        if (newDataReceived)\n+        {\n+            newDataReceived = false;\n+\n+            // Update only the necessary parts of the display\n+            tft.fillRect(0, 0, tft.width(), 20, ILI9341_BLACK); // Clear the top area\n+            tft.setTextColor(0xDED9);\n+            tft.setTextSize(4);\n+            tft.setFont(&FreeSansBold9pt7b);\n+            tft.setCursor(79, 62); // Set cursor position\n+            tft.print(hour);\n+            tft.setCursor(79, 124);\n+            tft.print(minute);\n+\n+            // Update Caps Lock status\n+            tft.fillRect(200, 0, 40, 20, ILI9341_BLACK); // Clear the Caps Lock area\n+            tft.setTextColor(capsLockStatus ? 0xFD40 : 0x7BEF); // ON or OFF\n+            tft.setCursor(206, 18);\n+            tft.print(capsLockStatus ? \"ON\" : \"OFF\");\n+\n+            // Update other UI elements\n+            tft.drawBitmap(182, 9, image_bluetooth_connected_bits, 14, 16, 0x9C1F);\n+            tft.drawBitmap(157, 9, image_cloud_sync_bits, 17, 16, 0xF22B);\n+            tft.drawBitmap(11, 9, image_menu_settings_sliders_bits, 14, 16, 0xDED9);\n+            tft.setFont(&FreeMonoBold12pt7b);\n+            tft.setCursor(18, 250);\n+            tft.print(\"Now Playing\");\n+            tft.setFont(&FreeMonoBold9pt7b);\n+            tft.setCursor(18, 274);\n+            tft.print(\"Bury you - Ari.\");\n+            tft.drawBitmap(198, 263, image_music_play_bits, 15, 16, 0xDED9);\n+            tft.setTextColor(0xFD40);\n+            tft.setCursor(90, 304);\n+            tft.print(\"3D Modeling\");\n+        }\n+\n+        vTaskDelay(100 / portTICK_PERIOD_MS); // Delay for 100ms (10Hz refresh rate)\n+    }\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737139744733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,68 @@\n+import serial\n+import os\n+import time\n+import subprocess\n+\n+# Find available USB ports\n+# List available ports\n+# Replace 'ttyUSB0' with the actual port if necessary\n+ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n+if ports:\n+    ser = serial.Serial(ports[0], 115200)\n+    print(f\"Connected to {ports[0]}\")\n+else:\n+    print(\"No USB device found\")\n+    exit()\n+\n+def send_data(caps_lock_status, hour, minute):\n+    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n+    ser.write(data.encode())\n+    print(f\"Sent: {data.strip()}\")\n+    \n+def get_caps_lock_status():\n+    try:\n+        output = subprocess.check_output(['xset', 'q'])\n+        output = output.decode('utf-8')\n+        for line in output.splitlines():\n+            if 'Caps Lock:' in line:\n+                return 'on' in line.split()[3]\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+        return 0\n+\n+# Initial values\n+caps_lock_status = \"false\"\n+hour = 12\n+minute = 34\n+\n+try:\n+    toggle_interval = 5  # Toggle caps_lock_status every 5 seconds\n+    last_toggle_time = time.time()\n+    \n+    while True:\n+        start_time = time.time()\n+        caps_lock_status = get_caps_lock_status()\n+        \n+        # Update caps_lock_status every toggle_interval seconds\n+        if time.time() - last_toggle_time >= toggle_interval:\n+            caps_lock_status = not caps_lock_status\n+            last_toggle_time = time.time()\n+        \n+        # Update hour and minute every minute\n+        current_time = time.localtime()\n+        hour = current_time.tm_hour\n+        minute = current_time.tm_min\n+        \n+        send_data(caps_lock_status, hour, minute)\n+        \n+        # Calculate the time taken to send the data\n+        elapsed_time = time.time() - start_time\n+        \n+        # Sleep for the remaining time to maintain 100 Hz (10 ms interval)\n+        sleep_time = max(0, 0.01 - elapsed_time)\n+        time.sleep(sleep_time)\n+except KeyboardInterrupt:\n+    print(\"Exiting...\")\n+finally:\n+    # Close the serial connection\n+    ser.close()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737397154718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,147 +1,83 @@\n+import time\n import serial\n import os\n-import time\n-import subprocess\n \n-# Find available USB ports\n-# List available ports\n-# Replace 'ttyUSB0' with the actual port if necessary\n-ports = [f'/dev/{port}' for port in ['ttyUSB0', 'ttyUSB1', 'ttyACM0'] if os.path.exists(f'/dev/{port}')]\n-if ports:\n-    ser = serial.Serial(ports[0], 115200)\n-    print(f\"Connected to {ports[0]}\")\n-else:\n-    print(\"No USB device found\")\n-    exit()\n+class ESP32Driver:\n+    def __init__(self, port, baudrate=115200):\n+        self.ser = serial.Serial(port, baudrate, timeout=1)\n+        self.caps_lock_status = self.get_caps_lock_status()\n+        self.connection_status = False\n+        self.update_connection_status(True)\n \n-def send_data(caps_lock_status, hour, minute):\n-    data = f\"{caps_lock_status},{hour},{minute}\\n\"\n-    ser.write(data.encode())\n-    print(f\"Sent: {data.strip()}\")\n-    \n-def get_caps_lock_status():\n-    try:\n-        output = subprocess.check_output(['xset', 'q'])\n-        output = output.decode('utf-8')\n-        for line in output.splitlines():\n-            if 'Caps Lock:' in line:\n-                return 'on' in line.split()[3]\n-    except Exception as e:\n-        print(f\"Error: {e}\")\n-        return 0\n+    def send_command(self, command):\n+        if self.ser.is_open:\n+            self.ser.write((command + \"\\n\").encode())\n+            response = self.ser.readline().decode().strip()\n+            return response\n+        else:\n+            raise ConnectionError(\"Serial connection is not open.\")\n \n-# Initial values\n-caps_lock_status = \"false\"\n-hour = 12\n-minute = 34\n+    def update_variable(self, variable, value):\n+        command = f\"{variable} {value}\"\n+        response = self.send_command(command)\n+        print(response)\n \n-try:\n-    toggle_interval = 5  # Toggle caps_lock_status every 5 seconds\n-    last_toggle_time = time.time()\n-    \n-    while True:\n-        start_time = time.time()\n-        caps_lock_status = get_caps_lock_status()\n-        \n-        # Update caps_lock_status every toggle_interval seconds\n-        if time.time() - last_toggle_time >= toggle_interval:\n-            caps_lock_status = not caps_lock_status\n-            last_toggle_time = time.time()\n-        \n-        # Update hour and minute every minute\n-        current_time = time.localtime()\n-        hour = current_time.tm_hour\n-        minute = current_time.tm_min\n-        \n-        send_data(caps_lock_status, hour, minute)\n-        \n-        # Calculate the time taken to send the data\n-        elapsed_time = time.time() - start_time\n-        \n-        # Sleep for the remaining time to maintain 100 Hz (10 ms interval)\n-        sleep_time = max(0, 0.01 - elapsed_time)\n-        time.sleep(sleep_time)\n-except KeyboardInterrupt:\n-    print(\"Exiting...\")\n-finally:\n-    # Close the serial connection\n-    ser.close()\n-#include <Adafruit_ILI9341.h>\n-#include \"UI/main.h\" // main screen UI elements\n+    def query_variable(self, variable):\n+        command = f\"{variable}?\"\n+        response = self.send_command(command)\n+        print(response)\n+        return response\n \n-#define LCD_CS 13\n-#define LCD_RST 17\n-#define LCD_RS 16\n-#define SPI_MOSI 12 // Connect to display's SDI (MOSI)\n-#define SPI_SCK 18  // Connect to display's SCK (clock)\n+    def update_caps_lock_status(self):\n+        new_status = self.get_caps_lock_status()\n+        if new_status != self.caps_lock_status:\n+            self.caps_lock_status = new_status\n+            self.update_variable(\"caps\", int(self.caps_lock_status))\n \n-Adafruit_ILI9341 tft = Adafruit_ILI9341(LCD_CS, LCD_RS, LCD_RST);\n+    def update_connection_status(self, status):\n+        self.connection_status = status\n+        self.update_variable(\"connectionStatus\", int(status))\n \n-void displayHandler(void *parameters)\n-{\n-    SPI.begin(SPI_SCK, -1, SPI_MOSI); // -1 means that the MISO pin is not used\n-    tft.begin();\n-    tft.invertDisplay(true); // Ensure normal color mode\n-    tft.setRotation(2);\n-    Serial.println(\"Display Handler started.\");\n+    def update_time(self, hours=None, minutes=None, seconds=None):\n+        if hours is not None:\n+            self.update_variable(\"time.hours\", hours)\n+        if minutes is not None:\n+            self.update_variable(\"time.minutes\", minutes)\n+        if seconds is not None:\n+            self.update_variable(\"time.seconds\", seconds)\n \n-    bool capsLockStatus = false;\n-    int hour = 0;\n-    int minute = 0;\n-    bool newDataReceived = false;\n+    @staticmethod\n+    def get_caps_lock_status():\n+        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n+        return caps_lock_state == \"on\"\n \n-    for (;;)\n-    {\n-        if (Serial.available())\n-        {\n-            String line = Serial.readStringUntil('\\n');\n-            Serial.println(line);\n+    def close(self):\n+        self.update_connection_status(False)\n+        if self.ser.is_open:\n+            self.ser.close()\n \n-            // Parse the received data\n-            int comma1 = line.indexOf(',');\n\\ No newline at end of file\n-            int comma2 = line.lastIndexOf(',');\n-            capsLockStatus = line.substring(0, comma1).toInt() == 1;\n-            hour = line.substring(comma1 + 1, comma2).toInt();\n-            minute = line.substring(comma2 + 1).toInt();\n-            newDataReceived = true;\n-        }\n+# Example usage:\n+if __name__ == \"__main__\":\n+    esp = ESP32Driver(port=\"/dev/ttyUSB0\")\n+    try:\n+        # Update time\n+        esp.update_time(hours=10, minutes=30, seconds=45)\n \n-        if (newDataReceived)\n-        {\n-            newDataReceived = false;\n+        # Query time\n+        esp.query_variable(\"time.hours\")\n+        esp.query_variable(\"time.minutes\")\n+        esp.query_variable(\"time.seconds\")\n \n-            // Update only the necessary parts of the display\n-            tft.fillRect(0, 0, tft.width(), 20, ILI9341_BLACK); // Clear the top area\n-            tft.setTextColor(0xDED9);\n-            tft.setTextSize(4);\n-            tft.setFont(&FreeSansBold9pt7b);\n-            tft.setCursor(79, 62); // Set cursor position\n-            tft.print(hour);\n-            tft.setCursor(79, 124);\n-            tft.print(minute);\n+        # Update caps lock status\n+        esp.update_caps_lock_status()\n \n-            // Update Caps Lock status\n-            tft.fillRect(200, 0, 40, 20, ILI9341_BLACK); // Clear the Caps Lock area\n-            tft.setTextColor(capsLockStatus ? 0xFD40 : 0x7BEF); // ON or OFF\n-            tft.setCursor(206, 18);\n-            tft.print(capsLockStatus ? \"ON\" : \"OFF\");\n+        # Query caps lock status\n+        esp.query_variable(\"caps\")\n \n-            // Update other UI elements\n-            tft.drawBitmap(182, 9, image_bluetooth_connected_bits, 14, 16, 0x9C1F);\n-            tft.drawBitmap(157, 9, image_cloud_sync_bits, 17, 16, 0xF22B);\n-            tft.drawBitmap(11, 9, image_menu_settings_sliders_bits, 14, 16, 0xDED9);\n-            tft.setFont(&FreeMonoBold12pt7b);\n-            tft.setCursor(18, 250);\n-            tft.print(\"Now Playing\");\n-            tft.setFont(&FreeMonoBold9pt7b);\n-            tft.setCursor(18, 274);\n-            tft.print(\"Bury you - Ari.\");\n-            tft.drawBitmap(198, 263, image_music_play_bits, 15, 16, 0xDED9);\n-            tft.setTextColor(0xFD40);\n-            tft.setCursor(90, 304);\n-            tft.print(\"3D Modeling\");\n-        }\n+        # Query connection status\n+        esp.query_variable(\"connectionStatus\")\n \n-        vTaskDelay(100 / portTICK_PERIOD_MS); // Delay for 100ms (10Hz refresh rate)\n-    }\n-}\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+    finally:\n+        esp.close()\n"
                },
                {
                    "date": 1737397278542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,83 @@\n+import time\n+import serial\n+import os\n+\n+class ESP32Driver:\n+    def __init__(self, port, baudrate=115200):\n+        self.ser = serial.Serial(port, baudrate, timeout=1)\n+        self.caps_lock_status = self.get_caps_lock_status()\n+        self.connection_status = False\n+        self.update_connection_status(True)\n+\n+    def send_command(self, command):\n+        if self.ser.is_open:\n+            self.ser.write((command + \"\\n\").encode())\n+            response = self.ser.readline().decode().strip()\n+            return response\n+        else:\n+            raise ConnectionError(\"Serial connection is not open.\")\n+\n+    def update_variable(self, variable, value):\n+        command = f\"{variable} {value}\"\n+        response = self.send_command(command)\n+        print(response)\n+\n+    def query_variable(self, variable):\n+        command = f\"{variable}?\"\n+        response = self.send_command(command)\n+        print(response)\n+        return response\n+\n+    def update_caps_lock_status(self):\n+        new_status = self.get_caps_lock_status()\n+        if new_status != self.caps_lock_status:\n+            self.caps_lock_status = new_status\n+            self.update_variable(\"caps\", int(self.caps_lock_status))\n+\n+    def update_connection_status(self, status):\n+        self.connection_status = status\n+        self.update_variable(\"connectionStatus\", int(status))\n+\n+    def update_time(self, hours=None, minutes=None, seconds=None):\n+        if hours is not None:\n+            self.update_variable(\"time.hours\", hours)\n+        if minutes is not None:\n+            self.update_variable(\"time.minutes\", minutes)\n+        if seconds is not None:\n+            self.update_variable(\"time.seconds\", seconds)\n+\n+    @staticmethod\n+    def get_caps_lock_status():\n+        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n+        return caps_lock_state == \"on\"\n+\n+    def close(self):\n+        self.update_connection_status(False)\n+        if self.ser.is_open:\n+            self.ser.close()\n+\n+# Example usage:\n+if __name__ == \"__main__\":\n+    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n+    try:\n+        # Update time\n+        esp.update_time(hours=10, minutes=30, seconds=45)\n+\n+        # Query time\n+        esp.query_variable(\"time.hours\")\n+        esp.query_variable(\"time.minutes\")\n+        esp.query_variable(\"time.seconds\")\n+\n+        # Update caps lock status\n+        esp.update_caps_lock_status()\n+\n+        # Query caps lock status\n+        esp.query_variable(\"caps\")\n+\n+        # Query connection status\n+        esp.query_variable(\"connectionStatus\")\n+\n+    except Exception as e:\n+        print(f\"Error: {e}\")\n+    finally:\n+        esp.close()\n"
                },
                {
                    "date": 1737397599956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import time\n import serial\n import os\n+from datetime import datetime\n \n class ESP32Driver:\n     def __init__(self, port, baudrate=115200):\n         self.ser = serial.Serial(port, baudrate, timeout=1)\n@@ -37,15 +38,13 @@\n     def update_connection_status(self, status):\n         self.connection_status = status\n         self.update_variable(\"connectionStatus\", int(status))\n \n-    def update_time(self, hours=None, minutes=None, seconds=None):\n-        if hours is not None:\n-            self.update_variable(\"time.hours\", hours)\n-        if minutes is not None:\n-            self.update_variable(\"time.minutes\", minutes)\n-        if seconds is not None:\n-            self.update_variable(\"time.seconds\", seconds)\n+    def update_time_from_system(self):\n+        now = datetime.now()\n+        self.update_variable(\"time.hours\", now.hour)\n+        self.update_variable(\"time.minutes\", now.minute)\n+        self.update_variable(\"time.seconds\", now.second)\n \n     @staticmethod\n     def get_caps_lock_status():\n         caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n@@ -55,112 +54,19 @@\n         self.update_connection_status(False)\n         if self.ser.is_open:\n             self.ser.close()\n \n-# Example usage:\n-if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n-    try:\n-        # Update time\n-        esp.update_time(hours=10, minutes=30, seconds=45)\n+    def run_forever(self):\n+        try:\n+            while True:\n+                self.update_time_from_system()\n+                self.update_caps_lock_status()\n+                time.sleep(1)  # Update every second\n+        except KeyboardInterrupt:\n+            print(\"Exiting driver loop...\")\n+        finally:\n+            self.close()\n \n-        # Query time\n-        esp.query_variable(\"time.hours\")\n-        esp.query_variable(\"time.minutes\")\n-        esp.query_variable(\"time.seconds\")\n-\n-        # Update caps lock status\n-        esp.update_caps_lock_status()\n-\n-        # Query caps lock status\n-        esp.query_variable(\"caps\")\n-\n-        # Query connection status\n-        esp.query_variable(\"connectionStatus\")\n-\n-    except Exception as e:\n-        print(f\"Error: {e}\")\n-    finally:\n-        esp.close()\n-import time\n-import serial\n-import os\n-\n-class ESP32Driver:\n-    def __init__(self, port, baudrate=115200):\n-        self.ser = serial.Serial(port, baudrate, timeout=1)\n-        self.caps_lock_status = self.get_caps_lock_status()\n-        self.connection_status = False\n-        self.update_connection_status(True)\n-\n-    def send_command(self, command):\n-        if self.ser.is_open:\n-            self.ser.write((command + \"\\n\").encode())\n-            response = self.ser.readline().decode().strip()\n-            return response\n-        else:\n-            raise ConnectionError(\"Serial connection is not open.\")\n-\n-    def update_variable(self, variable, value):\n-        command = f\"{variable} {value}\"\n-        response = self.send_command(command)\n-        print(response)\n-\n-    def query_variable(self, variable):\n-        command = f\"{variable}?\"\n-        response = self.send_command(command)\n-        print(response)\n-        return response\n-\n-    def update_caps_lock_status(self):\n-        new_status = self.get_caps_lock_status()\n-        if new_status != self.caps_lock_status:\n-            self.caps_lock_status = new_status\n-            self.update_variable(\"caps\", int(self.caps_lock_status))\n-\n-    def update_connection_status(self, status):\n-        self.connection_status = status\n-        self.update_variable(\"connectionStatus\", int(status))\n-\n-    def update_time(self, hours=None, minutes=None, seconds=None):\n-        if hours is not None:\n-            self.update_variable(\"time.hours\", hours)\n-        if minutes is not None:\n-            self.update_variable(\"time.minutes\", minutes)\n-        if seconds is not None:\n-            self.update_variable(\"time.seconds\", seconds)\n-\n-    @staticmethod\n-    def get_caps_lock_status():\n-        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n-        return caps_lock_state == \"on\"\n-\n-    def close(self):\n-        self.update_connection_status(False)\n-        if self.ser.is_open:\n-            self.ser.close()\n-\n # Example usage:\n if __name__ == \"__main__\":\n     esp = ESP32Driver(port=\"/dev/ttyUSB0\")\n-    try:\n-        # Update time\n-        esp.update_time(hours=10, minutes=30, seconds=45)\n-\n-        # Query time\n-        esp.query_variable(\"time.hours\")\n-        esp.query_variable(\"time.minutes\")\n-        esp.query_variable(\"time.seconds\")\n-\n-        # Update caps lock status\n-        esp.update_caps_lock_status()\n-\n-        # Query caps lock status\n-        esp.query_variable(\"caps\")\n-\n-        # Query connection status\n-        esp.query_variable(\"connectionStatus\")\n-\n-    except Exception as e:\n-        print(f\"Error: {e}\")\n-    finally:\n-        esp.close()\n+    esp.run_forever()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737397624932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -67,6 +67,6 @@\n             self.close()\n \n # Example usage:\n if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyUSB0\")\n+    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n     esp.run_forever()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737398078745,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,11 @@\n     def __init__(self, port, baudrate=115200):\n         self.ser = serial.Serial(port, baudrate, timeout=1)\n         self.caps_lock_status = self.get_caps_lock_status()\n         self.connection_status = False\n+        self.last_time_update = None\n         self.update_connection_status(True)\n+        self.update_time_from_system()  # Update time once during initialization\n \n     def send_command(self, command):\n         if self.ser.is_open:\n             self.ser.write((command + \"\\n\").encode())\n@@ -43,9 +45,16 @@\n         now = datetime.now()\n         self.update_variable(\"time.hours\", now.hour)\n         self.update_variable(\"time.minutes\", now.minute)\n         self.update_variable(\"time.seconds\", now.second)\n+        self.last_time_update = now\n \n+    def check_and_update_time(self):\n+        now = datetime.now()\n+        if self.last_time_update is None or now.hour != self.last_time_update.hour:\n+            print(\"System time has changed, updating ESP32 time...\")\n+            self.update_time_from_system()\n+\n     @staticmethod\n     def get_caps_lock_status():\n         caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n         return caps_lock_state == \"on\"\n@@ -57,16 +66,16 @@\n \n     def run_forever(self):\n         try:\n             while True:\n-                self.update_time_from_system()\n+                self.check_and_update_time()\n                 self.update_caps_lock_status()\n-                time.sleep(1)  # Update every second\n+                time.sleep(1)  # Check every second\n         except KeyboardInterrupt:\n             print(\"Exiting driver loop...\")\n         finally:\n             self.close()\n \n # Example usage:\n if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n+    esp = ESP32Driver(port=\"/dev/ttyUSB0\")\n     esp.run_forever()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737398099818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,81 @@\n+import time\n+import serial\n+import os\n+from datetime import datetime\n+\n+class ESP32Driver:\n+    def __init__(self, port, baudrate=115200):\n+        self.ser = serial.Serial(port, baudrate, timeout=1)\n+        self.caps_lock_status = self.get_caps_lock_status()\n+        self.connection_status = False\n+        self.last_time_update = None\n+        self.update_connection_status(True)\n+        self.update_time_from_system()  # Update time once during initialization\n+\n+    def send_command(self, command):\n+        if self.ser.is_open:\n+            self.ser.write((command + \"\\n\").encode())\n+            response = self.ser.readline().decode().strip()\n+            return response\n+        else:\n+            raise ConnectionError(\"Serial connection is not open.\")\n+\n+    def update_variable(self, variable, value):\n+        command = f\"{variable} {value}\"\n+        response = self.send_command(command)\n+        print(response)\n+\n+    def query_variable(self, variable):\n+        command = f\"{variable}?\"\n+        response = self.send_command(command)\n+        print(response)\n+        return response\n+\n+    def update_caps_lock_status(self):\n+        new_status = self.get_caps_lock_status()\n+        if new_status != self.caps_lock_status:\n+            self.caps_lock_status = new_status\n+            self.update_variable(\"caps\", int(self.caps_lock_status))\n+\n+    def update_connection_status(self, status):\n+        self.connection_status = status\n+        self.update_variable(\"connectionStatus\", int(status))\n+\n+    def update_time_from_system(self):\n+        now = datetime.now()\n+        self.update_variable(\"time.hours\", now.hour)\n+        self.update_variable(\"time.minutes\", now.minute)\n+        self.update_variable(\"time.seconds\", now.second)\n+        self.last_time_update = now\n+\n+    def check_and_update_time(self):\n+        now = datetime.now()\n+        if self.last_time_update is None or now.hour != self.last_time_update.hour:\n+            print(\"System time has changed, updating ESP32 time...\")\n+            self.update_time_from_system()\n+\n+    @staticmethod\n+    def get_caps_lock_status():\n+        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n+        return caps_lock_state == \"on\"\n+\n+    def close(self):\n+        self.update_connection_status(False)\n+        if self.ser.is_open:\n+            self.ser.close()\n+\n+    def run_forever(self):\n+        try:\n+            while True:\n+                self.check_and_update_time()\n+                self.update_caps_lock_status()\n+                time.sleep(1)  # Check every second\n+        except KeyboardInterrupt:\n+            print(\"Exiting driver loop...\")\n+        finally:\n+            self.close()\n+\n+# Example usage:\n+if __name__ == \"__main__\":\n+    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n+    esp.run_forever()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737403036809,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,97 +58,28 @@\n     def get_caps_lock_status():\n         caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n         return caps_lock_state == \"on\"\n \n-    def close(self):\n-        self.update_connection_status(False)\n-        if self.ser.is_open:\n-            self.ser.close()\n-\n-    def run_forever(self):\n+    def handle_reconnection(self):\n         try:\n-            while True:\n-                self.check_and_update_time()\n+            connection_status = int(self.query_variable(\"connectionStatus\"))\n+            if connection_status == 0:\n+                print(\"ESP32 connection lost. Reinitializing variables...\")\n+                self.update_connection_status(True)\n+                self.update_time_from_system()\n                 self.update_caps_lock_status()\n-                time.sleep(1)  # Check every second\n-        except KeyboardInterrupt:\n-            print(\"Exiting driver loop...\")\n-        finally:\n-            self.close()\n+        except Exception as e:\n+            print(f\"Error checking connection status: {e}\")\n \n-# Example usage:\n-if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n-    esp.run_forever()\n-import time\n-import serial\n-import os\n-from datetime import datetime\n-\n-class ESP32Driver:\n-    def __init__(self, port, baudrate=115200):\n-        self.ser = serial.Serial(port, baudrate, timeout=1)\n-        self.caps_lock_status = self.get_caps_lock_status()\n-        self.connection_status = False\n-        self.last_time_update = None\n-        self.update_connection_status(True)\n-        self.update_time_from_system()  # Update time once during initialization\n-\n-    def send_command(self, command):\n-        if self.ser.is_open:\n-            self.ser.write((command + \"\\n\").encode())\n-            response = self.ser.readline().decode().strip()\n-            return response\n-        else:\n-            raise ConnectionError(\"Serial connection is not open.\")\n-\n-    def update_variable(self, variable, value):\n-        command = f\"{variable} {value}\"\n-        response = self.send_command(command)\n-        print(response)\n-\n-    def query_variable(self, variable):\n-        command = f\"{variable}?\"\n-        response = self.send_command(command)\n-        print(response)\n-        return response\n-\n-    def update_caps_lock_status(self):\n-        new_status = self.get_caps_lock_status()\n-        if new_status != self.caps_lock_status:\n-            self.caps_lock_status = new_status\n-            self.update_variable(\"caps\", int(self.caps_lock_status))\n-\n-    def update_connection_status(self, status):\n-        self.connection_status = status\n-        self.update_variable(\"connectionStatus\", int(status))\n-\n-    def update_time_from_system(self):\n-        now = datetime.now()\n-        self.update_variable(\"time.hours\", now.hour)\n-        self.update_variable(\"time.minutes\", now.minute)\n-        self.update_variable(\"time.seconds\", now.second)\n-        self.last_time_update = now\n-\n-    def check_and_update_time(self):\n-        now = datetime.now()\n-        if self.last_time_update is None or now.hour != self.last_time_update.hour:\n-            print(\"System time has changed, updating ESP32 time...\")\n-            self.update_time_from_system()\n-\n-    @staticmethod\n-    def get_caps_lock_status():\n-        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n-        return caps_lock_state == \"on\"\n-\n     def close(self):\n         self.update_connection_status(False)\n         if self.ser.is_open:\n             self.ser.close()\n \n     def run_forever(self):\n         try:\n             while True:\n+                self.handle_reconnection()\n                 self.check_and_update_time()\n                 self.update_caps_lock_status()\n                 time.sleep(1)  # Check every second\n         except KeyboardInterrupt:\n@@ -157,6 +88,6 @@\n             self.close()\n \n # Example usage:\n if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyUSB0\")\n+    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n     esp.run_forever()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737403775388,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,100 @@\n+import time\n+import serial\n+import os\n+from datetime import datetime\n+\n+class ESP32Driver:\n+    def __init__(self, port, baudrate=115200):\n+        self.ser = serial.Serial(port, baudrate, timeout=1)\n+        self.caps_lock_status = self.get_caps_lock_status()\n+        self.connection_status = False\n+        self.last_time_update = None\n+        self.update_connection_status(True)\n+        self.update_time_from_system()  # Update time once during initialization\n+\n+    def send_command(self, command):\n+        if self.ser.is_open:\n+            try:\n+                self.ser.write((command + \"\\n\").encode())\n+                response = self.ser.readline().decode().strip()\n+                return response\n+            except Exception as e:\n+                raise ConnectionError(f\"Failed to send command: {e}\")\n+        else:\n+            raise ConnectionError(\"Serial connection is not open.\")\n+\n+    def update_variable(self, variable, value):\n+        command = f\"{variable} {value}\"\n+        response = self.send_command(command)\n+        print(response)\n+\n+    def query_variable(self, variable):\n+        command = f\"{variable}?\"\n+        response = self.send_command(command)\n+        print(response)\n+        return response.split()[-1]  # Extract the value from the response\n+\n+    def update_caps_lock_status(self):\n+        new_status = self.get_caps_lock_status()\n+        if new_status != self.caps_lock_status:\n+            self.caps_lock_status = new_status\n+            self.update_variable(\"caps\", int(self.caps_lock_status))\n+\n+    def update_connection_status(self, status):\n+        self.connection_status = status\n+        self.update_variable(\"connectionStatus\", int(status))\n+\n+    def update_time_from_system(self):\n+        now = datetime.now()\n+        self.update_variable(\"time.hours\", now.hour)\n+        self.update_variable(\"time.minutes\", now.minute)\n+        self.update_variable(\"time.seconds\", now.second)\n+        self.last_time_update = now\n+\n+    def check_and_update_time(self):\n+        now = datetime.now()\n+        if self.last_time_update is None or now.hour != self.last_time_update.hour:\n+            print(\"System time has changed, updating ESP32 time...\")\n+            self.update_time_from_system()\n+\n+    @staticmethod\n+    def get_caps_lock_status():\n+        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n+        return caps_lock_state == \"on\"\n+\n+    def handle_reconnection(self):\n+        try:\n+            connection_status = int(self.query_variable(\"connectionStatus\"))\n+            if connection_status == 0:\n+                print(\"ESP32 connection lost. Reinitializing variables...\")\n+                self.update_connection_status(True)\n+                self.update_time_from_system()\n+                self.update_caps_lock_status()\n+        except ValueError as e:\n+            print(f\"Error parsing connection status: {e}\")\n+        except ConnectionError as e:\n+            print(f\"Serial connection error: {e}\")\n+        except Exception as e:\n+            print(f\"Unexpected error: {e}\")\n+\n+    def close(self):\n+        self.update_connection_status(False)\n+        if self.ser.is_open:\n+            self.ser.close()\n+\n+    def run_forever(self):\n+        try:\n+            while True:\n+                self.handle_reconnection()\n+                self.check_and_update_time()\n+                self.update_caps_lock_status()\n+                time.sleep(1)  # Check every second\n+        except KeyboardInterrupt:\n+            print(\"Exiting driver loop...\")\n+        finally:\n+            self.close()\n+\n+# Example usage:\n+if __name__ == \"__main__\":\n+    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n+    esp.run_forever()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1737404912357,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,17 +4,30 @@\n from datetime import datetime\n \n class ESP32Driver:\n     def __init__(self, port, baudrate=115200):\n-        self.ser = serial.Serial(port, baudrate, timeout=1)\n+        self.port = port\n+        self.baudrate = baudrate\n+        self.ser = None\n         self.caps_lock_status = self.get_caps_lock_status()\n         self.connection_status = False\n         self.last_time_update = None\n-        self.update_connection_status(True)\n-        self.update_time_from_system()  # Update time once during initialization\n+        self.connect_to_serial()\n \n+    def connect_to_serial(self):\n+        while True:\n+            try:\n+                self.ser = serial.Serial(self.port, self.baudrate, timeout=1)\n+                print(\"Serial connection established.\")\n+                self.update_connection_status(True)\n+                self.update_time_from_system()  # Update time once during initialization\n+                return\n+            except serial.SerialException as e:\n+                print(f\"Failed to connect to serial port: {e}. Retrying in 5 seconds...\")\n+                time.sleep(5)\n+\n     def send_command(self, command):\n-        if self.ser.is_open:\n+        if self.ser and self.ser.is_open:\n             try:\n                 self.ser.write((command + \"\\n\").encode())\n                 response = self.ser.readline().decode().strip()\n                 return response\n@@ -58,9 +71,9 @@\n             self.update_time_from_system()\n \n     @staticmethod\n     def get_caps_lock_status():\n-        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n+        caps_lock_state = os.popen('xset q | grep Caps | awk '{print $4}'').read().strip()\n         return caps_lock_state == \"on\"\n \n     def handle_reconnection(self):\n         try:\n@@ -69,111 +82,20 @@\n                 print(\"ESP32 connection lost. Reinitializing variables...\")\n                 self.update_connection_status(True)\n                 self.update_time_from_system()\n                 self.update_caps_lock_status()\n-        except ValueError as e:\n-            print(f\"Error parsing connection status: {e}\")\n-        except ConnectionError as e:\n-            print(f\"Serial connection error: {e}\")\n-        except Exception as e:\n-            print(f\"Unexpected error: {e}\")\n+        except (ValueError, ConnectionError):\n+            print(\"Connection to ESP32 lost. Attempting to reconnect...\")\n+            self.reconnect()\n \n-    def close(self):\n-        self.update_connection_status(False)\n-        if self.ser.is_open:\n+    def reconnect(self):\n+        if self.ser:\n             self.ser.close()\n+        self.connect_to_serial()\n \n-    def run_forever(self):\n-        try:\n-            while True:\n-                self.handle_reconnection()\n-                self.check_and_update_time()\n-                self.update_caps_lock_status()\n-                time.sleep(1)  # Check every second\n-        except KeyboardInterrupt:\n-            print(\"Exiting driver loop...\")\n-        finally:\n-            self.close()\n-\n-# Example usage:\n-if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n-    esp.run_forever()\n-import time\n-import serial\n-import os\n-from datetime import datetime\n-\n-class ESP32Driver:\n-    def __init__(self, port, baudrate=115200):\n-        self.ser = serial.Serial(port, baudrate, timeout=1)\n-        self.caps_lock_status = self.get_caps_lock_status()\n-        self.connection_status = False\n-        self.last_time_update = None\n-        self.update_connection_status(True)\n-        self.update_time_from_system()  # Update time once during initialization\n-\n-    def send_command(self, command):\n-        if self.ser.is_open:\n-            self.ser.write((command + \"\\n\").encode())\n-            response = self.ser.readline().decode().strip()\n-            return response\n-        else:\n-            raise ConnectionError(\"Serial connection is not open.\")\n-\n-    def update_variable(self, variable, value):\n-        command = f\"{variable} {value}\"\n-        response = self.send_command(command)\n-        print(response)\n-\n-    def query_variable(self, variable):\n-        command = f\"{variable}?\"\n-        response = self.send_command(command)\n-        print(response)\n-        return response\n-\n-    def update_caps_lock_status(self):\n-        new_status = self.get_caps_lock_status()\n-        if new_status != self.caps_lock_status:\n-            self.caps_lock_status = new_status\n-            self.update_variable(\"caps\", int(self.caps_lock_status))\n-\n-    def update_connection_status(self, status):\n-        self.connection_status = status\n-        self.update_variable(\"connectionStatus\", int(status))\n-\n-    def update_time_from_system(self):\n-        now = datetime.now()\n-        self.update_variable(\"time.hours\", now.hour)\n-        self.update_variable(\"time.minutes\", now.minute)\n-        self.update_variable(\"time.seconds\", now.second)\n-        self.last_time_update = now\n-\n-    def check_and_update_time(self):\n-        now = datetime.now()\n-        if self.last_time_update is None or now.hour != self.last_time_update.hour:\n-            print(\"System time has changed, updating ESP32 time...\")\n-            self.update_time_from_system()\n-\n-    @staticmethod\n-    def get_caps_lock_status():\n-        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n-        return caps_lock_state == \"on\"\n-\n-    def handle_reconnection(self):\n-        try:\n-            connection_status = int(self.query_variable(\"connectionStatus\"))\n-            if connection_status == 0:\n-                print(\"ESP32 connection lost. Reinitializing variables...\")\n-                self.update_connection_status(True)\n-                self.update_time_from_system()\n-                self.update_caps_lock_status()\n-        except Exception as e:\n-            print(f\"Error checking connection status: {e}\")\n-\n     def close(self):\n         self.update_connection_status(False)\n-        if self.ser.is_open:\n+        if self.ser and self.ser.is_open:\n             self.ser.close()\n \n     def run_forever(self):\n         try:\n"
                },
                {
                    "date": 1737405003613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n             self.update_time_from_system()\n \n     @staticmethod\n     def get_caps_lock_status():\n-        caps_lock_state = os.popen('xset q | grep Caps | awk '{print $4}'').read().strip()\n+        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n         return caps_lock_state == \"on\"\n \n     def handle_reconnection(self):\n         try:\n"
                },
                {
                    "date": 1737405063666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,10 +21,10 @@\n                 self.update_connection_status(True)\n                 self.update_time_from_system()  # Update time once during initialization\n                 return\n             except serial.SerialException as e:\n-                print(f\"Failed to connect to serial port: {e}. Retrying in 5 seconds...\")\n-                time.sleep(5)\n+                print(f\"Failed to connect to serial port: {e}. Retrying in 1 seconds...\")\n+                time.sleep(1)\n \n     def send_command(self, command):\n         if self.ser and self.ser.is_open:\n             try:\n"
                },
                {
                    "date": 1737407623041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n             while True:\n                 self.handle_reconnection()\n                 self.check_and_update_time()\n                 self.update_caps_lock_status()\n-                time.sleep(1)  # Check every second\n+                time.sleep(0.3)  # Check every second\n         except KeyboardInterrupt:\n             print(\"Exiting driver loop...\")\n         finally:\n             self.close()\n"
                },
                {
                    "date": 1737407630126,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n             while True:\n                 self.handle_reconnection()\n                 self.check_and_update_time()\n                 self.update_caps_lock_status()\n-                time.sleep(0.3)  # Check every second\n+                time.sleep(0.3)  # Check every .3 seconds\n         except KeyboardInterrupt:\n             print(\"Exiting driver loop...\")\n         finally:\n             self.close()\n"
                },
                {
                    "date": 1737407648526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n             while True:\n                 self.handle_reconnection()\n                 self.check_and_update_time()\n                 self.update_caps_lock_status()\n-                time.sleep(0.3)  # Check every .3 seconds\n+                time.sleep(0.1)  # Check every .1 seconds\n         except KeyboardInterrupt:\n             print(\"Exiting driver loop...\")\n         finally:\n             self.close()\n"
                },
                {
                    "date": 1737407994156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -102,9 +102,9 @@\n             while True:\n                 self.handle_reconnection()\n                 self.check_and_update_time()\n                 self.update_caps_lock_status()\n-                time.sleep(0.1)  # Check every .1 seconds\n+                #time.sleep(0.1)  # Check every .1 seconds\n         except KeyboardInterrupt:\n             print(\"Exiting driver loop...\")\n         finally:\n             self.close()\n"
                },
                {
                    "date": 1737408375085,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,115 +1,21 @@\n-import time\n-import serial\n-import os\n-from datetime import datetime\n+import dbus\n \n-class ESP32Driver:\n-    def __init__(self, port, baudrate=115200):\n-        self.port = port\n-        self.baudrate = baudrate\n-        self.ser = None\n-        self.caps_lock_status = self.get_caps_lock_status()\n-        self.connection_status = False\n-        self.last_time_update = None\n-        self.connect_to_serial()\n+def get_playing_media():\n+    try:\n+        session_bus = dbus.SessionBus()\n+        players = [service for service in session_bus.list_names() if service.startswith('org.mpris.MediaPlayer2.')]\n+        for player in players:\n+            proxy = session_bus.get_object(player, '/org/mpris/MediaPlayer2')\n+            interface = dbus.Interface(proxy, 'org.freedesktop.DBus.Properties')\n+            status = interface.Get('org.mpris.MediaPlayer2.Player', 'PlaybackStatus')\n+            if status == \"Playing\":\n+                metadata = interface.Get('org.mpris.MediaPlayer2.Player', 'Metadata')\n+                title = metadata.get('xesam:title', 'Unknown Title')\n+                artist = metadata.get('xesam:artist', ['Unknown Artist'])[0]\n+                return f\"{artist} - {title}\"\n+        return \"No Media\"\n+    except Exception as e:\n+        return f\"Error: {e}\"\n \n-    def connect_to_serial(self):\n-        while True:\n-            try:\n-                self.ser = serial.Serial(self.port, self.baudrate, timeout=1)\n-                print(\"Serial connection established.\")\n-                self.update_connection_status(True)\n-                self.update_time_from_system()  # Update time once during initialization\n-                return\n-            except serial.SerialException as e:\n-                print(f\"Failed to connect to serial port: {e}. Retrying in 1 seconds...\")\n-                time.sleep(1)\n-\n-    def send_command(self, command):\n-        if self.ser and self.ser.is_open:\n-            try:\n-                self.ser.write((command + \"\\n\").encode())\n-                response = self.ser.readline().decode().strip()\n-                return response\n-            except Exception as e:\n-                raise ConnectionError(f\"Failed to send command: {e}\")\n-        else:\n-            raise ConnectionError(\"Serial connection is not open.\")\n-\n-    def update_variable(self, variable, value):\n-        command = f\"{variable} {value}\"\n-        response = self.send_command(command)\n-        print(response)\n-\n-    def query_variable(self, variable):\n-        command = f\"{variable}?\"\n-        response = self.send_command(command)\n-        print(response)\n-        return response.split()[-1]  # Extract the value from the response\n-\n-    def update_caps_lock_status(self):\n-        new_status = self.get_caps_lock_status()\n-        if new_status != self.caps_lock_status:\n-            self.caps_lock_status = new_status\n-            self.update_variable(\"caps\", int(self.caps_lock_status))\n-\n-    def update_connection_status(self, status):\n-        self.connection_status = status\n-        self.update_variable(\"connectionStatus\", int(status))\n-\n-    def update_time_from_system(self):\n-        now = datetime.now()\n-        self.update_variable(\"time.hours\", now.hour)\n-        self.update_variable(\"time.minutes\", now.minute)\n-        self.update_variable(\"time.seconds\", now.second)\n-        self.last_time_update = now\n-\n-    def check_and_update_time(self):\n-        now = datetime.now()\n-        if self.last_time_update is None or now.hour != self.last_time_update.hour:\n-            print(\"System time has changed, updating ESP32 time...\")\n-            self.update_time_from_system()\n-\n-    @staticmethod\n-    def get_caps_lock_status():\n-        caps_lock_state = os.popen('xset q | grep Caps | awk \\'{print $4}\\'').read().strip()\n-        return caps_lock_state == \"on\"\n-\n-    def handle_reconnection(self):\n-        try:\n-            connection_status = int(self.query_variable(\"connectionStatus\"))\n-            if connection_status == 0:\n-                print(\"ESP32 connection lost. Reinitializing variables...\")\n-                self.update_connection_status(True)\n-                self.update_time_from_system()\n-                self.update_caps_lock_status()\n-        except (ValueError, ConnectionError):\n-            print(\"Connection to ESP32 lost. Attempting to reconnect...\")\n-            self.reconnect()\n-\n-    def reconnect(self):\n-        if self.ser:\n-            self.ser.close()\n-        self.connect_to_serial()\n-\n-    def close(self):\n-        self.update_connection_status(False)\n-        if self.ser and self.ser.is_open:\n-            self.ser.close()\n\\ No newline at end of file\n-\n-    def run_forever(self):\n-        try:\n-            while True:\n-                self.handle_reconnection()\n-                self.check_and_update_time()\n-                self.update_caps_lock_status()\n-                #time.sleep(0.1)  # Check every .1 seconds\n-        except KeyboardInterrupt:\n-            print(\"Exiting driver loop...\")\n-        finally:\n-            self.close()\n-\n-# Example usage:\n if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n-    esp.run_forever()\n+    print(get_playing_media())\n"
                },
                {
                    "date": 1737408395093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -110,5 +110,6 @@\n             self.close()\n \n # Example usage:\n if __name__ == \"__main__\":\n-    esp = ESP32Driver(port=\"/d\n\\ No newline at end of file\n+    esp = ESP32Driver(port=\"/dev/ttyACM0\")\n+    esp.run_forever()\n\\ No newline at end of file\n"
                }
            ],
            "date": 1736973983020,
            "name": "Commit-0",
            "content": "import usb_hid\nfrom adafruit_hid.keyboard import Keyboard\nfrom adafruit_hid.keyboard_layout_us import KeyboardLayoutUS\nimport board\nimport busio\nimport time\n\n# Initialize USB HID components\ni2c = busio.I2C(board.SCL, board.SDA)\nkbd = Keyboard(usb_hid.devices)\nlayout = KeyboardLayoutUS(kbd)\n\ndef get_caps_lock_status():\n    # Keyboard LED states\n    return kbd.get_leds()\n\ndef get_current_time():\n    return time.strftime(\"%Y-%m-%d %H:%M:%S\")\n\nwhile True:\n    caps_lock_status = get_caps_lock_status()\n    is_caps_lock_on = bool(caps_lock_status & 0b001)  # Mask with 0b001 to check Caps Lock state\n    \n    # Get current time\n    current_time = get_current_time()\n    print(f\"Caps Lock: {is_caps_lock_on}, Time: {current_time}\")\n\n    # Send Caps Lock status and current time\n    if is_caps_lock_on:\n        kbd.press(KEY_CAPS_LOCK)\n    else:\n        kbd.release(KEY_CAPS_LOCK)\n\n    time.sleep(1)\n"
        }
    ]
}